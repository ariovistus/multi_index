Building a topographical sort with multi_index

The primer:

As you may be aware, one of DMD's more nefarious proclivities is to refuse to
compile cyclically dependent modules, thus it is wise to maintain an acyclic 
dependency graph. Topographical sorts prove useful for ensuring your graph
is acyclic, or for isolating cyclic subgraphs. This was the impetus for my 
original interest in topographical sorts, and it provides a problem for our 
solution.

Given a graph G, a topographical sort of G will return a partial 
ordering of the nodes of G as determined by {something}.
For example, a topographical sort of the tree

      A
     /  \
    B    C
  / | \  | \
 D  E  F G  H

might return D E F B G H C A.

How do you perform a topographical sort?

Probably there are multiple ways.

The one I like, though, is a destructive removal of nodes of order 1. 
Afterwards, If there are no nodes left, then G is acyclic. Otherwise, the 
remaining nodes form a cyclic subgraph, and each node is part of some cycle.

We can use a heap to quickly find a node of order 1, however, on removal of the
node, we must update the position of its siblings in the heap. 

Some data:

D's standard library is not acyclic (which is occassionally a source of pain 
for the developers). Let us use a topographical sort to find the subset of the
modules which are in such a cycle. From the bash prompt:

cd dmd2/src/phobos/std/
find -name \*.d -exec dmd -c -o- -deps={}.txt {} \; -exec install -D {}.txt ~/dgraph/ \;

Each resulting txt file will contain lines of the form

$module_name ($file_name): $access : $symbol ($symbol_file)

For example, for the files m1.d, m2.d, m3.d:


module m1;
int rhombus;

module m2;
import m1;
import m3;

int quadrilateral(){
    return rhombus - square;
}

module m3;
int square;


dmd -c -o- -deps=deps.txt will result in the following content:

m2 (m2.d) : public : object (/usr/include/d/object.di)
m1 (m1.d) : public : object (/usr/include/d/object.di)
m2 (m2.d) : public : m1 (m1.d)
m3 (m3.d) : public : object (/usr/include/d/object.di)
m2 (m2.d) : public : m3 (m3.d)


